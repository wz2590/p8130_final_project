---
title: "data_exploration"
author: "Weiheng Zhang"
date: "2021/11/28"
output: github_document
---

```{r message = FALSE}
library(tidyverse)
library(lubridate)
library(dplyr)
library(p8105.datasets)
library(leaflet)
library(mgcv)
library(modelr)
library(corrplot)
library(MASS)
library(performance)


theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```


## Data cleaning

```{r message = FALSE, warning = FALSE}
cdi =
  read_csv("./data/cdi.csv") %>% 
  mutate(
    cty = as.factor(cty),
    state = as.factor(state),
    region = factor(region, levels = c("1", "2", "3", "4"),
                    labels = c("Northeast", "North_Central", "South", "West")),
    CRM_1000 = 1000*crimes/pop #每1000人中的犯罪数量(county level)
  ) %>% 
  relocate(CRM_1000)

cdi
```

## Descriptive Statistics.
```{r}
summary(cdi)
```

```{r}
sapply(cdi, function(x) sum(is.na(x)))
```
No missing values were found.



## Identify counties with unusual crime rates.
```{r}
upper = quantile(cdi$CRM_1000, 0.75)
lower = quantile(cdi$CRM_1000, 0.25)
IQR = upper - lower

cdi %>% 
  filter(CRM_1000 > upper + 1.5*IQR,
         CRM_1000 > lower - 1.5*IQR) %>% 
  dplyr::select(cty, CRM_1000) %>%
  knitr::kable(digits = 2)


cdi %>% 
  ggplot(aes(x = "", y = CRM_1000))+
  geom_boxplot() + 
  labs(title = "Counties' CRM_1000 Values",)
```


## Group by states and check for outliers again.
```{r}
cdi_state = 
  cdi %>% 
  group_by(state) %>% 
  summarise(state_pop = sum(pop),
            state_crimes = sum(crimes)) %>% 
  mutate(state_CRM_1000 = 1000*state_crimes/state_pop) %>% 
  relocate(state_CRM_1000)

cdi_state
```

```{r}
upper = quantile(cdi_state$state_CRM_1000, 0.75)
lower = quantile(cdi_state$state_CRM_1000, 0.25)
IQR = upper - lower

cdi_state %>% 
  filter(state_CRM_1000 > upper + 1.5*IQR,
         state_CRM_1000 > lower - 1.5*IQR) %>% 
  dplyr::select(state, state_CRM_1000) %>%
  knitr::kable(digits = 2)


cdi_state %>% 
  ggplot(aes(x = "", y = state_CRM_1000))+
  geom_boxplot() + 
  labs(title = "States' CRM_1000 Values",)
```
  
Surprisingly, if we look at the CRM_1000 at state level, no outlier was found.







## Check for transformation

```{r}
# fit multivariate model
mult.fit1 = lm(CRM_1000 ~ poverty + region + state + area + pop + pop18 + pop65 + hsgrad + bagrad + unemp + pcincome + totalinc, data = cdi) 

# check diagnostics
plot(mult.fit1)
boxcox(mult.fit1)
```

## a = 1/2. Perform sqrt transformation.

```{r}
cdi = 
  cdi %>% 
  mutate(sqrt_CRM_1000 = sqrt(CRM_1000))

mult.fit2 = lm(sqrt_CRM_1000 ~ poverty + region + state + area + pop + pop18 + pop65 + hsgrad + bagrad + unemp + pcincome + totalinc, data = cdi) 

# check diagnostics
summary(mult.fit2)
plot(mult.fit2)
boxcox(mult.fit2) 
```


## Checking to Outliers and Influential Points

```{r}
# residuals vs leverage plot
plot(mult.fit1, which = 4)

# remove influential points
cdiOut = cdi[-c(1, 6),]

# plot with and without influential points
plot(cdi$poverty, cdi$CRM_1000)
plot(cdiOut$poverty, cdiOut$CRM_1000)

# fit model with and without influential points
with = lm(CRM_1000 ~ poverty + region + state + area + pop + pop18 + pop65 + hsgrad + bagrad + unemp + pcincome + totalinc, data = cdi) 

without = lm(CRM_1000 ~ poverty + region + state + area + pop + pop18 + pop65 + hsgrad + bagrad + unemp + pcincome + totalinc, data = cdiOut) 

summary(with); summary(without)

# check without diagnostics
plot(without)
```




## Initial Exploration of correlation between counties' CRM_100 and all variables, With untransformed outcome (CRM_1000)
## 好像除了poverty, region和state之外都看不出什么明显关联（捂脸）

```{r}
cdi %>% ggplot(aes(x = area, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pop, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pop18, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pop65, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = docs, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = beds, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = hsgrad, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = bagrad, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = poverty, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = unemp, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pcincome, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = totalinc, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = region, y = CRM_1000)) + geom_boxplot()
cdi %>% ggplot(aes(y = state, x = CRM_1000)) + geom_boxplot()
```

## In your multiple regression model, be careful of variables that are highly correlated and be selective of the ones that you choose to include in the analysis. 

```{r}
new_cdi = 
  cdi %>%
  mutate(
    state = as.numeric(state),
    region = as.numeric(region)
  ) %>% 
  dplyr::select(-id, -cty, -CRM_1000)

pairs(new_cdi)

cor(new_cdi)

corrplot(cor(new_cdi), type = "upper", diag = FALSE)

mult.fit = lm(new_cdi$sqrt_CRM_1000 ~ ., data = new_cdi)
summary(mult.fit)
check_collinearity(mult.fit)
```


```{r}
mult.fit %>% 
  broom::tidy() %>% 
  knitr::kable(digits = 3)
```

```{r}
new_cdi %>% 
  modelr::add_predictions(mult.fit) %>% 
  modelr::add_residuals(mult.fit) %>% 
  ggplot(aes(x = pred, y = resid)) + 
  geom_point()
  
```

```{r}
mod_select = step(mult.fit, direction = 'backward')
```

```{r}
our_new_model = lm(sqrt_CRM_1000 ~ id + area + pop + pop18 + pop65 + beds + crimes + bagrad + poverty + pcincome + region, data = new_cdi)

new_cdi %>% 
  modelr::add_residuals(our_new_model) %>% 
  modelr::add_predictions(our_new_model) %>% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point()
```

Do crossvalidation 
```{r}
mod_df = 
  new_cdi %>% 
  dplyr::select(sqrt_CRM_1000, id, area, pop, pop18, pop65, beds, crimes, bagrad, poverty, pcincome, region)

cv_mod = 
  crossv_mc(mod_df, 100) %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))

cv_mod = 
  cv_mod %>% 
  mutate(
    model_1  = map(train, ~lm(sqrt_CRM_1000 ~ id + area + pop + pop18 + pop65 + beds + crimes + bagrad + poverty + pcincome + region, data = .x))) %>%
  mutate(
    rmse_model_1 = map2_dbl(model_1, test, ~rmse(model = .x, data = .y)))


```

Plot the prediction error distribution for each model.

```{r}
cv_mod %>% 
  dplyr::select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + 
  geom_violin()
```





