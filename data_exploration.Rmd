---
title: "data_exploration"
author: "Weiheng Zhang"
date: "2021/11/28"
output: github_document
---

```{r message = FALSE}
library(tidyverse)
library(lubridate)
library(dplyr)
library(p8105.datasets)
library(leaflet)
library(mgcv)
library(modelr)

theme_set(theme_minimal() + theme(legend.position = "bottom"))

options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

scale_colour_discrete = scale_color_viridis_d
scale_fill_discrete = scale_fill_viridis_d
```


## Data cleaning

```{r message = FALSE, warning = FALSE}
cdi =
  read_csv("./data/cdi.csv") %>% 
  mutate(
    cty = as.factor(cty),
    state = as.factor(state),
    region = factor(region, levels = c("1", "2", "3", "4"),
                    labels = c("Northeast", "North_Central", "South", "West")),
    CRM_1000 = 1000*crimes/pop #每1000人中的犯罪数量(county level)
  ) %>% 
  relocate(CRM_1000)

cdi
```

## Descriptive Statistics.
```{r}
summary(cdi)
```

```{r}
sapply(cdi, function(x) sum(is.na(x)))
```
No missing values were found.



## Identify counties with unusual crime rates.
```{r}
upper = quantile(cdi$CRM_1000, 0.75)
lower = quantile(cdi$CRM_1000, 0.25)
IQR = upper - lower

cdi %>% 
  filter(CRM_1000 > upper + 1.5*IQR,
         CRM_1000 > lower - 1.5*IQR) %>% 
  dplyr::select(cty, CRM_1000) %>%
  knitr::kable(digits = 2)


cdi %>% 
  ggplot(aes(x = "", y = CRM_1000))+
  geom_boxplot() + 
  labs(title = "Counties' CRM_1000 Values",)
```


## Group by states and check for outliers again.
## This part may require updates to include other variables.
```{r}
cdi_state = 
  cdi %>% 
  group_by(state) %>% 
  summarise(state_pop = sum(pop),
            state_crimes = sum(crimes)) %>% 
  mutate(state_CRM_1000 = 1000*state_crimes/state_pop) %>% 
  relocate(state_CRM_1000)

cdi_state
```

```{r}
upper = quantile(cdi_state$state_CRM_1000, 0.75)
lower = quantile(cdi_state$state_CRM_1000, 0.25)
IQR = upper - lower

cdi_state %>% 
  filter(state_CRM_1000 > upper + 1.5*IQR,
         state_CRM_1000 > lower - 1.5*IQR) %>% 
  dplyr::select(state, state_CRM_1000) %>%
  knitr::kable(digits = 2)


cdi_state %>% 
  ggplot(aes(x = "", y = state_CRM_1000))+
  geom_boxplot() + 
  labs(title = "States' CRM_1000 Values",)
```
  
Surprisingly, if we look at the CRM_1000 at state level, no outlier was found.




## Check if counties' CRM_1000 Distribution is skewed
```{r}
cdi %>% 
  ggplot(aes(x = CRM_1000)) +
  geom_histogram(color="white", aes(y = ..density..)) + 
  geom_density() +
  labs(
    title = "Histogram of CRM_1000" ,
    x = "Crimes per 1000 people",
    y = "Density"
  )
```
  
Seems that this is not that skewed. Do we need a log transformation?  

## Perform log transformation and redraw the histogram.  
```{r}
cdi_trans = 
  cdi %>% 
  mutate(CRM_1000 = log(CRM_1000))

cdi_trans %>% 
  ggplot(aes(x = CRM_1000)) +
  geom_histogram(color="white", aes(y = ..density..)) + 
  geom_density() +
  labs(
    title = "Histogram of CRM_1000" ,
    x = "Crimes per 1000 people",
    y = "Density"
  )
```
  
这看上去怎么感觉还不如不搞transformation...等周一上完课再看吧。



## Initial Exploration of correlation between counties' CRM_100 and all variables, With untransformed outcome (CRM_1000)
## 好像除了poverty之外都看不出什么明显关联（捂脸）

```{r}
cdi %>% ggplot(aes(x = area, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pop, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pop18, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pop65, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = docs, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = beds, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = hsgrad, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = bagrad, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = poverty, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = unemp, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = pcincome, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = totalinc, y = CRM_1000)) + geom_point()
cdi %>% ggplot(aes(x = region, y = CRM_1000)) + geom_boxplot()
```

## In your multiple regression model, be careful of variables that are highly correlated and be selective of the ones that you choose to include in the analysis. 

```{r}
our_model = 
  lm(CRM_1000 ~ id  + cty + state + area + pop + pop18 + pop65 + docs + beds + crimes + hsgrad + bagrad + poverty + unemp + pcincome + totalinc + region, data = cdi)

our_model %>% 
  broom::tidy() %>% 
  knitr::kable(digits = 3)
```

```{r}
cdi %>% 
  modelr::add_predictions(our_model) %>% 
  modelr::add_residuals(our_model) %>% 
  ggplot(aes(x = pred, y = resid)) + 
  geom_point()
  
```

```{r}
mod_select = step(our_model, direction = 'backward')
```

```{r}
our_new_model = lm(CRM_1000 ~ id + cty + state + area + pop + pop18 + docs + beds + crimes + hsgrad + poverty + unemp + totalinc, data = cdi)

cdi %>% 
  modelr::add_residuals(our_new_model) %>% 
  modelr::add_predictions(our_new_model) %>% 
  ggplot(aes(x = pred, y = resid)) +
  geom_point()
```

Do crossvalidation 
```{r}
mod_df = 
  cdi %>% 
  select(CRM_1000, id , cty , state , area , pop , pop18 , docs , beds , crimes , hsgrad , poverty , unemp , totalinc)

cv_mod = 
  crossv_mc(mod_df, 100) %>% 
  mutate(
    train = map(train, as_tibble),
    test = map(test, as_tibble))

cv_mod = 
  cv_mod %>% 
  mutate(
    model_1  = map(train, ~lm(CRM_1000 ~ id + area + pop + pop18 + docs + beds + crimes + hsgrad + poverty + unemp + totalinc, data = .x))) %>%
  mutate(
    rmse_model_1 = map2_dbl(model_1, test, ~rmse(model = .x, data = .y)))


```

Plot the prediction error distribution for each model.

```{r}
cv_mod %>% 
  select(starts_with("rmse")) %>% 
  pivot_longer(
    everything(),
    names_to = "model", 
    values_to = "rmse",
    names_prefix = "rmse_") %>% 
  mutate(model = fct_inorder(model)) %>% 
  ggplot(aes(x = model, y = rmse)) + 
  geom_violin()
```





